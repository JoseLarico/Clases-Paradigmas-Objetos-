{"level":"info","message":"⌛ Building environment","timeElapsed":303,"timestamp":"2024-09-15T18:43:11.274Z"}
{"level":"info","message":"onRequest - WORKSPACE_URI:file:///e%3A/UTN17/Paradigmas/OBJETOS/Clases-Paradigmas-Objetos-","timestamp":"2024-09-15T18:43:11.283Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":185,"timestamp":"2024-09-15T18:43:11.472Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":201,"timestamp":"2024-09-15T18:43:11.688Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":368,"timestamp":"2024-09-15T18:43:12.056Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":300,"timestamp":"2024-09-15T18:43:12.370Z"}
{"level":"info","message":"⌛ Validating Clases/clase-1.wlk","timeElapsed":386,"timestamp":"2024-09-15T18:43:12.786Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":469,"timestamp":"2024-09-15T18:43:13.268Z"}
{"level":"info","message":"⌛ Validating Clases/clase-1.wlk","timeElapsed":412,"timestamp":"2024-09-15T18:43:13.681Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":357,"timestamp":"2024-09-16T02:07:43.025Z"}
{"level":"info","message":"onRequest - WORKSPACE_URI:file:///e%3A/UTN17/Paradigmas/OBJETOS/Clases-Paradigmas-Objetos-","timestamp":"2024-09-16T02:07:43.031Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":177,"timestamp":"2024-09-16T02:07:43.211Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":163,"timestamp":"2024-09-16T02:07:43.398Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":338,"timestamp":"2024-09-16T02:07:43.739Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":134,"timestamp":"2024-09-16T02:07:43.877Z"}
{"level":"info","message":"⌛ Validating Clases/clase-1.wlk","timeElapsed":179,"timestamp":"2024-09-16T02:07:44.064Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":222,"timestamp":"2024-09-16T02:07:44.287Z"}
{"level":"info","message":"⌛ Validating Clases/clase-1.wlk","timeElapsed":178,"timestamp":"2024-09-16T02:07:44.465Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:07:53.437Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":102,"timestamp":"2024-09-16T02:07:54.070Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":103,"timestamp":"2024-09-16T02:07:54.174Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":107,"timestamp":"2024-09-16T02:07:55.666Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":106,"timestamp":"2024-09-16T02:07:56.005Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":103,"timestamp":"2024-09-16T02:07:56.170Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:07:57.222Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":104,"timestamp":"2024-09-16T02:07:57.451Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:07:57.718Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":144,"timestamp":"2024-09-16T02:07:59.631Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:08:01.817Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":105,"timestamp":"2024-09-16T02:08:04.029Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":113,"timestamp":"2024-09-16T02:08:59.661Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":114,"timestamp":"2024-09-16T02:08:59.922Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":144,"timestamp":"2024-09-16T02:09:03.068Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":122,"timestamp":"2024-09-16T02:09:03.202Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":114,"timestamp":"2024-09-16T02:09:03.501Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":135,"timestamp":"2024-09-16T02:09:03.643Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":102,"timestamp":"2024-09-16T02:09:04.347Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:04.666Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:04.824Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:05.280Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:05.875Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":114,"timestamp":"2024-09-16T02:09:06.662Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:09:06.929Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":133,"timestamp":"2024-09-16T02:09:07.253Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:09:08.943Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:09:11.941Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:12.180Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":110,"timestamp":"2024-09-16T02:09:12.555Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:12.578Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:14.438Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:14.716Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":102,"timestamp":"2024-09-16T02:09:16.048Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:16.321Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":109,"timestamp":"2024-09-16T02:09:17.049Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":117,"timestamp":"2024-09-16T02:09:17.909Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:09:20.988Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:22:10.745Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:22:10.932Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:22:13.218Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":114,"timestamp":"2024-09-16T02:22:15.502Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":106,"timestamp":"2024-09-16T02:22:15.693Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":116,"timestamp":"2024-09-16T02:22:16.744Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:16.745Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":127,"timestamp":"2024-09-16T02:22:16.993Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":148,"timestamp":"2024-09-16T02:22:17.237Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:22:17.407Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:22:18.583Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:22:18.745Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:19.102Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:22:20.920Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:31.031Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:31.089Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:31.280Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":146,"timestamp":"2024-09-16T02:22:31.427Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":137,"timestamp":"2024-09-16T02:22:31.565Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:22:31.748Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":102,"timestamp":"2024-09-16T02:22:35.612Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:35.613Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:35.676Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":123,"timestamp":"2024-09-16T02:22:36.868Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":113,"timestamp":"2024-09-16T02:22:37.241Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":112,"timestamp":"2024-09-16T02:22:37.444Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:22:41.424Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":126,"timestamp":"2024-09-16T02:22:42.252Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:42.253Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:42.320Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":118,"timestamp":"2024-09-16T02:22:42.439Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:42.499Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":167,"timestamp":"2024-09-16T02:22:42.666Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":151,"timestamp":"2024-09-16T02:22:42.824Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":105,"timestamp":"2024-09-16T02:22:43.073Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:22:45.030Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"fileName":"Clases/clase-2.wlk","id":"4f9a25de-acaa-44ed-84f4-a661a694c11e","imports":[],"members":[{"id":"ebbc44e3-4f2a-44f9-8301-14f74d29114c","members":[{"id":"69cc3075-2ce7-46b3-ae21-92af5a22e42a","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":5,"line":126,"offset":3615}},"value":{"id":"5ba21f8c-c917-495e-af6d-9c341f337255","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":29,"line":126,"offset":3639}},"value":3}},{"body":{"id":"38e8297c-755a-4859-bb7d-d0ffc9e3edb9","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"a12ca521-97c3-43de-a674-652722ca1ee8","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":9,"line":129,"offset":3684}},"value":{"args":[{"id":"6c12e0fc-24ad-4749-a5a2-c81e23dc4748","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":31,"line":129,"offset":3706}}}],"id":"3a37eaed-177b-45fa-b45f-c9970fd3359c","message":"*","metadata":[],"receiver":{"id":"f5145467-ea84-4111-bb1b-0c02958bf535","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":129,"offset":3703},"start":{"column":20,"line":129,"offset":3695}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":20,"line":129,"offset":3695}}},"variable":{"id":"552018da-3983-499c-98f8-093662ac2663","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":129,"offset":3692},"start":{"column":9,"line":129,"offset":3684}}}}],"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":26,"line":128,"offset":3673}}},"id":"ede54acc-4d00-482b-a230-28ce3e853fb9","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":5,"line":128,"offset":3652}}},{"body":{"id":"db27585b-5101-4c3c-a1fa-226a39495a39","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"43a8fb59-bb2b-4cb6-b467-aedb21fb9ac0","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"52d1b975-e435-4681-991c-b813b3f42a87","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"494057db-8f86-408c-ac69-6784440388e7","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"7c627257-22db-4b64-b81b-b80d02470524","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"296e8fd9-5131-4b69-9570-df349204482b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"64d2dbfe-752f-455b-b6c5-68a75a7a594a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"be3c0bf4-b3df-47d2-b178-edc6f39c8f3c","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"69aef4a9-6bff-45ed-982a-85bbb01a730d","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"31e26e23-4a17-4071-a856-5e8baee2d8e0","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"// --------------------------CLASE 2-----------------------------------------"},"name":"comment"},{"args":{"position":"start","text":"/* CONCEPTOS Y OTRAS COSAS\r\nLo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r\nmodelar es lo primero en lo que tenemos que pensar\r\n\r\nOtro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r\nal menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r\nEl polimorfismo es un concepto que permite que diferentes objetos puedan \r\nrecibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r\ninterfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r\n\r\nEn Paradigmas tenemos que saber que TODO puede ser un objeto.\r\n\r\nLos metodos con efecto los reconocemos porque modifican las referencias de \r\nlos objetos, en cambio los de retonrno no lo hacen\r\nCLAVE\r\n-Si retorna -> es de pregunta/retorno\r\n-Si no retorna -> es de efecto/accion\r\n\r\n*,+,&&,|| tambien son mensajes pero de retorno    */"},"name":"comment"},{"args":{"position":"start","text":"/* FECHAS\r\n Metodos para manejar con fechas:\r\n\r\n> const hoy = new Date()\r\n✓\r\n> hoy\r\n✓ 24/11/2017\r\n> hoy.plusYears(1)                 // sumo un año\r\n✓ 24/11/2018                      // devuelve una nueva fecha\r\n> hoy.plusMonths(2)               // sumo 2 meses\r\n✓ 24/1/2018\r\n> hoy.plusDays(20)\r\n✓ 14/12/2017\r\n> hoy.isLeapYear()                // pregunto si el año es bisiesto\r\n✓ false\r\n> hoy.dayOfWeek()                // qué día de la semana es\r\n✓ \"friday\"\r\n> hoy.month()\r\n✓ 11\r\n> hoy.year()\r\n✓ 2017\r\n> const ayer = hoy.minusDays(1)\r\n✓                              // resto un día para obtener el día de ayer\r\n> ayer < hoy                   // comparo fechas\r\n✓ true\r\n> ayer - hoy                   // comparo fechas\r\n✓ -1                          // diferencia en días entre ayer y hoy\r\n> const haceUnMes = hoy.minusMonths(1)\r\n✓\r\n> ayer.between(haceUnMes, hoy)\r\n✓ true                        // ayer está entre hace un mes y hoy\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r\nEn funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r\nbloques que nos van a ayudar a:\r\n-poder generar referencias a dichos bloques\r\n-pasarlos como parámetro\r\n-elegir en qué momento ejecutar una porción de código\r\n\r\n1) Ejemplo de bloque sin parametro\r\n> const abs4 = { => 4.abs() }        \r\n✓\r\n> abs4\r\n✓ { => 4.abs() }\r\n> abs4.apply()                        Con apply() la invocamos para aplicarla\r\n✓ 4\r\n\r\n2) Ejemplo de bloque con parametro (se pueden parametrizar)\r\n>>> const abs = { numero => numero.abs() }\r\n>>\r\n✓\r\n> abs\r\n✓ { numero => numero.abs() }\r\n>>> abs.apply(-8)                     pasamos el parametro mediante el apply\r\n✓ 8\r\n\r\n3) Bloques con dos parámetros \t\r\n> { num1, num2 => num1.max(num2) }.apply(4, 2)\r\n✓ 4\r\n> { num1, num2 => num1 + num2 }.apply(4, 2)\r\n✓ 6\r\n\r\nO bien podemos currificarlo:\r\n> { num1 => { num2 => num1 + num2 }}.apply(4)\r\n✓ { num2 => num1 + num2 }   // devuelve un bloque\r\n\r\n> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r\n✓ 6\r\n\r\n4) Contexto de los bloques\r\nUn dato importante de los closures es que no solo acceden a sus parámetros, \r\nsino también a cualquier otra referencia en el contexto donde fueron definidas. \r\nEsto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r\n\r\n> var to = \"world\"\r\n✓\r\n> const helloWorld = { \"hello \" + to }\r\n✓\r\n> helloWorld.apply()      \t\t\r\n✓ \"hello world\"\r\n> to = \"someone else\"\r\n✓\r\n> helloWorld.apply()      \t\r\n✓ \"hello someone else\"\r\n\r\n> var num = 5\r\n✓\r\n> const bloque = { otroNum => num + otroNum }\r\n✓\r\n> bloque.apply(6)      \t\t\r\n✓ 11\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*\r\n ORDEN SUPERIOR\r\nTambien existen estas funciones que esperan bloques como parametros (retorno) */"},"name":"comment"}],"name":"x","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":131,"offset":3720},"start":{"column":1,"line":125,"offset":3599}},"supertypes":[]},{"id":"34a0abb7-1d76-4d3a-9f46-131e9187589c","members":[{"id":"24e2c8f7-22c8-400e-a3a1-d531b5cd7629","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":5,"line":133,"offset":3738}},"value":{"id":"555a5375-6591-457b-b270-2e759f502619","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":29,"line":133,"offset":3762}},"value":1}},{"body":{"id":"d65bf05d-7f0e-4a6b-864b-fa9461066550","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"2e9543d6-d80a-4c29-9aef-14e7eba55e5e","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":9,"line":136,"offset":3803}},"value":{"args":[{"id":"a7c00001-9526-4200-895f-4b6c1f913f2f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":31,"line":136,"offset":3825}},"value":1}],"id":"4e2ba616-d06f-479a-84ac-fb8c3946060d","message":"+","metadata":[],"receiver":{"id":"4a21b4bf-7234-44ba-8448-37fe08b8b1b4","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":136,"offset":3822},"start":{"column":20,"line":136,"offset":3814}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":20,"line":136,"offset":3814}}},"variable":{"id":"8e83e791-ed3b-4bfa-a471-8d975dbc3ebe","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":136,"offset":3811},"start":{"column":9,"line":136,"offset":3803}}}}],"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":26,"line":135,"offset":3792}}},"id":"b6879720-edd5-426e-b13b-295161df87a8","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":5,"line":135,"offset":3771}}},{"body":{"id":"34db235b-71e7-4f1c-8d5e-67e00cd7a1cc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"94481280-49a4-458b-b73a-a83371475705","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"befef50c-4c0f-4559-a027-2158c50a283d","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"4e3ec355-b3d0-4812-bc5b-1b6eb072ad65","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"5a84e867-4c56-4a0c-9426-3f8ebf42565b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"3b827d65-ddbe-465e-8f21-347a30c10bf4","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"1222c847-6a6b-4b4c-bb07-dadb59457cca","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"e785d452-58ae-4736-98e8-6f046e881cd0","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"0bb2058a-cec1-4e8b-a3d2-a6fb3c75241f","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"814e2a4e-a933-4386-8bba-ec9069483fb6","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"end","text":"/*\r\n>const lista = [x,y]\r\n> lista.filter({objeto => objeto.atributo() >2})\r\n[x]\r\n> lista.map({objeto => objeto.atributo()})\r\n[3,1]\r\n> lista.any ({objeto => objeto.atributo() == 3})\r\ntrue\r\n\r\nY tambien tenemos un metodo que tiene efecto \r\n\r\nlista.forEach({objeto => objeto.incrementar()})\r\n\r\nImportante si queremos usar metodos con efecto vamos a usar forEach solamente,\r\nno map, filter, any, all  */"},"name":"comment"}],"name":"y","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":138,"offset":3832},"start":{"column":1,"line":132,"offset":3722}},"supertypes":[]}],"metadata":[],"name":"clase-2","problems":[{"code":"malformedEntity","sourceMap":{"end":{"column":2,"line":195,"offset":6137},"start":{"column":1,"line":188,"offset":6071}}}],"scope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:22:53.156Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"fileName":"Clases/clase-2.wlk","id":"4f9a25de-acaa-44ed-84f4-a661a694c11e","imports":[],"members":[{"id":"ebbc44e3-4f2a-44f9-8301-14f74d29114c","members":[{"id":"69cc3075-2ce7-46b3-ae21-92af5a22e42a","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":5,"line":126,"offset":3615}},"value":{"id":"5ba21f8c-c917-495e-af6d-9c341f337255","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":29,"line":126,"offset":3639}},"value":3}},{"body":{"id":"38e8297c-755a-4859-bb7d-d0ffc9e3edb9","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"a12ca521-97c3-43de-a674-652722ca1ee8","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":9,"line":129,"offset":3684}},"value":{"args":[{"id":"6c12e0fc-24ad-4749-a5a2-c81e23dc4748","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":31,"line":129,"offset":3706}}}],"id":"3a37eaed-177b-45fa-b45f-c9970fd3359c","message":"*","metadata":[],"receiver":{"id":"f5145467-ea84-4111-bb1b-0c02958bf535","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":129,"offset":3703},"start":{"column":20,"line":129,"offset":3695}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":20,"line":129,"offset":3695}}},"variable":{"id":"552018da-3983-499c-98f8-093662ac2663","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":129,"offset":3692},"start":{"column":9,"line":129,"offset":3684}}}}],"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":26,"line":128,"offset":3673}}},"id":"ede54acc-4d00-482b-a230-28ce3e853fb9","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":5,"line":128,"offset":3652}}},{"body":{"id":"db27585b-5101-4c3c-a1fa-226a39495a39","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"43a8fb59-bb2b-4cb6-b467-aedb21fb9ac0","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"52d1b975-e435-4681-991c-b813b3f42a87","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"494057db-8f86-408c-ac69-6784440388e7","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"7c627257-22db-4b64-b81b-b80d02470524","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"296e8fd9-5131-4b69-9570-df349204482b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"64d2dbfe-752f-455b-b6c5-68a75a7a594a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"be3c0bf4-b3df-47d2-b178-edc6f39c8f3c","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"69aef4a9-6bff-45ed-982a-85bbb01a730d","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"31e26e23-4a17-4071-a856-5e8baee2d8e0","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"// --------------------------CLASE 2-----------------------------------------"},"name":"comment"},{"args":{"position":"start","text":"/* CONCEPTOS Y OTRAS COSAS\r\nLo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r\nmodelar es lo primero en lo que tenemos que pensar\r\n\r\nOtro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r\nal menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r\nEl polimorfismo es un concepto que permite que diferentes objetos puedan \r\nrecibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r\ninterfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r\n\r\nEn Paradigmas tenemos que saber que TODO puede ser un objeto.\r\n\r\nLos metodos con efecto los reconocemos porque modifican las referencias de \r\nlos objetos, en cambio los de retonrno no lo hacen\r\nCLAVE\r\n-Si retorna -> es de pregunta/retorno\r\n-Si no retorna -> es de efecto/accion\r\n\r\n*,+,&&,|| tambien son mensajes pero de retorno    */"},"name":"comment"},{"args":{"position":"start","text":"/* FECHAS\r\n Metodos para manejar con fechas:\r\n\r\n> const hoy = new Date()\r\n✓\r\n> hoy\r\n✓ 24/11/2017\r\n> hoy.plusYears(1)                 // sumo un año\r\n✓ 24/11/2018                      // devuelve una nueva fecha\r\n> hoy.plusMonths(2)               // sumo 2 meses\r\n✓ 24/1/2018\r\n> hoy.plusDays(20)\r\n✓ 14/12/2017\r\n> hoy.isLeapYear()                // pregunto si el año es bisiesto\r\n✓ false\r\n> hoy.dayOfWeek()                // qué día de la semana es\r\n✓ \"friday\"\r\n> hoy.month()\r\n✓ 11\r\n> hoy.year()\r\n✓ 2017\r\n> const ayer = hoy.minusDays(1)\r\n✓                              // resto un día para obtener el día de ayer\r\n> ayer < hoy                   // comparo fechas\r\n✓ true\r\n> ayer - hoy                   // comparo fechas\r\n✓ -1                          // diferencia en días entre ayer y hoy\r\n> const haceUnMes = hoy.minusMonths(1)\r\n✓\r\n> ayer.between(haceUnMes, hoy)\r\n✓ true                        // ayer está entre hace un mes y hoy\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r\nEn funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r\nbloques que nos van a ayudar a:\r\n-poder generar referencias a dichos bloques\r\n-pasarlos como parámetro\r\n-elegir en qué momento ejecutar una porción de código\r\n\r\n1) Ejemplo de bloque sin parametro\r\n> const abs4 = { => 4.abs() }        \r\n✓\r\n> abs4\r\n✓ { => 4.abs() }\r\n> abs4.apply()                        Con apply() la invocamos para aplicarla\r\n✓ 4\r\n\r\n2) Ejemplo de bloque con parametro (se pueden parametrizar)\r\n>>> const abs = { numero => numero.abs() }\r\n>>\r\n✓\r\n> abs\r\n✓ { numero => numero.abs() }\r\n>>> abs.apply(-8)                     pasamos el parametro mediante el apply\r\n✓ 8\r\n\r\n3) Bloques con dos parámetros \t\r\n> { num1, num2 => num1.max(num2) }.apply(4, 2)\r\n✓ 4\r\n> { num1, num2 => num1 + num2 }.apply(4, 2)\r\n✓ 6\r\n\r\nO bien podemos currificarlo:\r\n> { num1 => { num2 => num1 + num2 }}.apply(4)\r\n✓ { num2 => num1 + num2 }   // devuelve un bloque\r\n\r\n> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r\n✓ 6\r\n\r\n4) Contexto de los bloques\r\nUn dato importante de los closures es que no solo acceden a sus parámetros, \r\nsino también a cualquier otra referencia en el contexto donde fueron definidas. \r\nEsto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r\n\r\n> var to = \"world\"\r\n✓\r\n> const helloWorld = { \"hello \" + to }\r\n✓\r\n> helloWorld.apply()      \t\t\r\n✓ \"hello world\"\r\n> to = \"someone else\"\r\n✓\r\n> helloWorld.apply()      \t\r\n✓ \"hello someone else\"\r\n\r\n> var num = 5\r\n✓\r\n> const bloque = { otroNum => num + otroNum }\r\n✓\r\n> bloque.apply(6)      \t\t\r\n✓ 11\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*\r\n ORDEN SUPERIOR\r\nTambien existen estas funciones que esperan bloques como parametros (retorno) */"},"name":"comment"}],"name":"x","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":131,"offset":3720},"start":{"column":1,"line":125,"offset":3599}},"supertypes":[]},{"id":"34a0abb7-1d76-4d3a-9f46-131e9187589c","members":[{"id":"24e2c8f7-22c8-400e-a3a1-d531b5cd7629","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":5,"line":133,"offset":3738}},"value":{"id":"555a5375-6591-457b-b270-2e759f502619","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":29,"line":133,"offset":3762}},"value":1}},{"body":{"id":"d65bf05d-7f0e-4a6b-864b-fa9461066550","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"2e9543d6-d80a-4c29-9aef-14e7eba55e5e","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":9,"line":136,"offset":3803}},"value":{"args":[{"id":"a7c00001-9526-4200-895f-4b6c1f913f2f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":31,"line":136,"offset":3825}},"value":1}],"id":"4e2ba616-d06f-479a-84ac-fb8c3946060d","message":"+","metadata":[],"receiver":{"id":"4a21b4bf-7234-44ba-8448-37fe08b8b1b4","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":136,"offset":3822},"start":{"column":20,"line":136,"offset":3814}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":20,"line":136,"offset":3814}}},"variable":{"id":"8e83e791-ed3b-4bfa-a471-8d975dbc3ebe","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":136,"offset":3811},"start":{"column":9,"line":136,"offset":3803}}}}],"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":26,"line":135,"offset":3792}}},"id":"b6879720-edd5-426e-b13b-295161df87a8","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":5,"line":135,"offset":3771}}},{"body":{"id":"34db235b-71e7-4f1c-8d5e-67e00cd7a1cc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"94481280-49a4-458b-b73a-a83371475705","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"befef50c-4c0f-4559-a027-2158c50a283d","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"4e3ec355-b3d0-4812-bc5b-1b6eb072ad65","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"5a84e867-4c56-4a0c-9426-3f8ebf42565b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"3b827d65-ddbe-465e-8f21-347a30c10bf4","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"1222c847-6a6b-4b4c-bb07-dadb59457cca","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"e785d452-58ae-4736-98e8-6f046e881cd0","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"0bb2058a-cec1-4e8b-a3d2-a6fb3c75241f","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"814e2a4e-a933-4386-8bba-ec9069483fb6","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"end","text":"/*\r\n>const lista = [x,y]\r\n> lista.filter({objeto => objeto.atributo() >2})\r\n[x]\r\n> lista.map({objeto => objeto.atributo()})\r\n[3,1]\r\n> lista.any ({objeto => objeto.atributo() == 3})\r\ntrue\r\n\r\nY tambien tenemos un metodo que tiene efecto \r\n\r\nlista.forEach({objeto => objeto.incrementar()})\r\n\r\nImportante si queremos usar metodos con efecto vamos a usar forEach solamente,\r\nno map, filter, any, all  */"},"name":"comment"}],"name":"y","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":138,"offset":3832},"start":{"column":1,"line":132,"offset":3722}},"supertypes":[]}],"metadata":[],"name":"clase-2","problems":[{"code":"malformedEntity","sourceMap":{"end":{"column":2,"line":195,"offset":6137},"start":{"column":1,"line":188,"offset":6071}}}],"scope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:22:54.693Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"fileName":"Clases/clase-2.wlk","id":"4f9a25de-acaa-44ed-84f4-a661a694c11e","imports":[],"members":[{"id":"ebbc44e3-4f2a-44f9-8301-14f74d29114c","members":[{"id":"69cc3075-2ce7-46b3-ae21-92af5a22e42a","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":5,"line":126,"offset":3615}},"value":{"id":"5ba21f8c-c917-495e-af6d-9c341f337255","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":29,"line":126,"offset":3639}},"value":3}},{"body":{"id":"38e8297c-755a-4859-bb7d-d0ffc9e3edb9","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"a12ca521-97c3-43de-a674-652722ca1ee8","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":9,"line":129,"offset":3684}},"value":{"args":[{"id":"6c12e0fc-24ad-4749-a5a2-c81e23dc4748","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":31,"line":129,"offset":3706}}}],"id":"3a37eaed-177b-45fa-b45f-c9970fd3359c","message":"*","metadata":[],"receiver":{"id":"f5145467-ea84-4111-bb1b-0c02958bf535","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":129,"offset":3703},"start":{"column":20,"line":129,"offset":3695}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":20,"line":129,"offset":3695}}},"variable":{"id":"552018da-3983-499c-98f8-093662ac2663","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":129,"offset":3692},"start":{"column":9,"line":129,"offset":3684}}}}],"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":26,"line":128,"offset":3673}}},"id":"ede54acc-4d00-482b-a230-28ce3e853fb9","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":5,"line":128,"offset":3652}}},{"body":{"id":"db27585b-5101-4c3c-a1fa-226a39495a39","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"43a8fb59-bb2b-4cb6-b467-aedb21fb9ac0","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"52d1b975-e435-4681-991c-b813b3f42a87","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"494057db-8f86-408c-ac69-6784440388e7","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"7c627257-22db-4b64-b81b-b80d02470524","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"296e8fd9-5131-4b69-9570-df349204482b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"64d2dbfe-752f-455b-b6c5-68a75a7a594a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"be3c0bf4-b3df-47d2-b178-edc6f39c8f3c","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"69aef4a9-6bff-45ed-982a-85bbb01a730d","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"31e26e23-4a17-4071-a856-5e8baee2d8e0","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"// --------------------------CLASE 2-----------------------------------------"},"name":"comment"},{"args":{"position":"start","text":"/* CONCEPTOS Y OTRAS COSAS\r\nLo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r\nmodelar es lo primero en lo que tenemos que pensar\r\n\r\nOtro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r\nal menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r\nEl polimorfismo es un concepto que permite que diferentes objetos puedan \r\nrecibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r\ninterfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r\n\r\nEn Paradigmas tenemos que saber que TODO puede ser un objeto.\r\n\r\nLos metodos con efecto los reconocemos porque modifican las referencias de \r\nlos objetos, en cambio los de retonrno no lo hacen\r\nCLAVE\r\n-Si retorna -> es de pregunta/retorno\r\n-Si no retorna -> es de efecto/accion\r\n\r\n*,+,&&,|| tambien son mensajes pero de retorno    */"},"name":"comment"},{"args":{"position":"start","text":"/* FECHAS\r\n Metodos para manejar con fechas:\r\n\r\n> const hoy = new Date()\r\n✓\r\n> hoy\r\n✓ 24/11/2017\r\n> hoy.plusYears(1)                 // sumo un año\r\n✓ 24/11/2018                      // devuelve una nueva fecha\r\n> hoy.plusMonths(2)               // sumo 2 meses\r\n✓ 24/1/2018\r\n> hoy.plusDays(20)\r\n✓ 14/12/2017\r\n> hoy.isLeapYear()                // pregunto si el año es bisiesto\r\n✓ false\r\n> hoy.dayOfWeek()                // qué día de la semana es\r\n✓ \"friday\"\r\n> hoy.month()\r\n✓ 11\r\n> hoy.year()\r\n✓ 2017\r\n> const ayer = hoy.minusDays(1)\r\n✓                              // resto un día para obtener el día de ayer\r\n> ayer < hoy                   // comparo fechas\r\n✓ true\r\n> ayer - hoy                   // comparo fechas\r\n✓ -1                          // diferencia en días entre ayer y hoy\r\n> const haceUnMes = hoy.minusMonths(1)\r\n✓\r\n> ayer.between(haceUnMes, hoy)\r\n✓ true                        // ayer está entre hace un mes y hoy\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r\nEn funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r\nbloques que nos van a ayudar a:\r\n-poder generar referencias a dichos bloques\r\n-pasarlos como parámetro\r\n-elegir en qué momento ejecutar una porción de código\r\n\r\n1) Ejemplo de bloque sin parametro\r\n> const abs4 = { => 4.abs() }        \r\n✓\r\n> abs4\r\n✓ { => 4.abs() }\r\n> abs4.apply()                        Con apply() la invocamos para aplicarla\r\n✓ 4\r\n\r\n2) Ejemplo de bloque con parametro (se pueden parametrizar)\r\n>>> const abs = { numero => numero.abs() }\r\n>>\r\n✓\r\n> abs\r\n✓ { numero => numero.abs() }\r\n>>> abs.apply(-8)                     pasamos el parametro mediante el apply\r\n✓ 8\r\n\r\n3) Bloques con dos parámetros \t\r\n> { num1, num2 => num1.max(num2) }.apply(4, 2)\r\n✓ 4\r\n> { num1, num2 => num1 + num2 }.apply(4, 2)\r\n✓ 6\r\n\r\nO bien podemos currificarlo:\r\n> { num1 => { num2 => num1 + num2 }}.apply(4)\r\n✓ { num2 => num1 + num2 }   // devuelve un bloque\r\n\r\n> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r\n✓ 6\r\n\r\n4) Contexto de los bloques\r\nUn dato importante de los closures es que no solo acceden a sus parámetros, \r\nsino también a cualquier otra referencia en el contexto donde fueron definidas. \r\nEsto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r\n\r\n> var to = \"world\"\r\n✓\r\n> const helloWorld = { \"hello \" + to }\r\n✓\r\n> helloWorld.apply()      \t\t\r\n✓ \"hello world\"\r\n> to = \"someone else\"\r\n✓\r\n> helloWorld.apply()      \t\r\n✓ \"hello someone else\"\r\n\r\n> var num = 5\r\n✓\r\n> const bloque = { otroNum => num + otroNum }\r\n✓\r\n> bloque.apply(6)      \t\t\r\n✓ 11\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*\r\n ORDEN SUPERIOR\r\nTambien existen estas funciones que esperan bloques como parametros (retorno) */"},"name":"comment"}],"name":"x","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":131,"offset":3720},"start":{"column":1,"line":125,"offset":3599}},"supertypes":[]},{"id":"34a0abb7-1d76-4d3a-9f46-131e9187589c","members":[{"id":"24e2c8f7-22c8-400e-a3a1-d531b5cd7629","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":5,"line":133,"offset":3738}},"value":{"id":"555a5375-6591-457b-b270-2e759f502619","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":29,"line":133,"offset":3762}},"value":1}},{"body":{"id":"d65bf05d-7f0e-4a6b-864b-fa9461066550","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"2e9543d6-d80a-4c29-9aef-14e7eba55e5e","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":9,"line":136,"offset":3803}},"value":{"args":[{"id":"a7c00001-9526-4200-895f-4b6c1f913f2f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":31,"line":136,"offset":3825}},"value":1}],"id":"4e2ba616-d06f-479a-84ac-fb8c3946060d","message":"+","metadata":[],"receiver":{"id":"4a21b4bf-7234-44ba-8448-37fe08b8b1b4","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":136,"offset":3822},"start":{"column":20,"line":136,"offset":3814}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":20,"line":136,"offset":3814}}},"variable":{"id":"8e83e791-ed3b-4bfa-a471-8d975dbc3ebe","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":136,"offset":3811},"start":{"column":9,"line":136,"offset":3803}}}}],"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":26,"line":135,"offset":3792}}},"id":"b6879720-edd5-426e-b13b-295161df87a8","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":5,"line":135,"offset":3771}}},{"body":{"id":"34db235b-71e7-4f1c-8d5e-67e00cd7a1cc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"94481280-49a4-458b-b73a-a83371475705","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"befef50c-4c0f-4559-a027-2158c50a283d","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"4e3ec355-b3d0-4812-bc5b-1b6eb072ad65","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"5a84e867-4c56-4a0c-9426-3f8ebf42565b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"3b827d65-ddbe-465e-8f21-347a30c10bf4","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"1222c847-6a6b-4b4c-bb07-dadb59457cca","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"e785d452-58ae-4736-98e8-6f046e881cd0","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"0bb2058a-cec1-4e8b-a3d2-a6fb3c75241f","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"814e2a4e-a933-4386-8bba-ec9069483fb6","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"end","text":"/*\r\n>const lista = [x,y]\r\n> lista.filter({objeto => objeto.atributo() >2})\r\n[x]\r\n> lista.map({objeto => objeto.atributo()})\r\n[3,1]\r\n> lista.any ({objeto => objeto.atributo() == 3})\r\ntrue\r\n\r\nY tambien tenemos un metodo que tiene efecto \r\n\r\nlista.forEach({objeto => objeto.incrementar()})\r\n\r\nImportante si queremos usar metodos con efecto vamos a usar forEach solamente,\r\nno map, filter, any, all  */"},"name":"comment"}],"name":"y","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":138,"offset":3832},"start":{"column":1,"line":132,"offset":3722}},"supertypes":[]}],"metadata":[],"name":"clase-2","problems":[{"code":"malformedEntity","sourceMap":{"end":{"column":2,"line":195,"offset":6137},"start":{"column":1,"line":188,"offset":6071}}}],"scope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:22:55.151Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"fileName":"Clases/clase-2.wlk","id":"4f9a25de-acaa-44ed-84f4-a661a694c11e","imports":[],"members":[{"id":"ebbc44e3-4f2a-44f9-8301-14f74d29114c","members":[{"id":"69cc3075-2ce7-46b3-ae21-92af5a22e42a","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":5,"line":126,"offset":3615}},"value":{"id":"5ba21f8c-c917-495e-af6d-9c341f337255","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":29,"line":126,"offset":3639}},"value":3}},{"body":{"id":"38e8297c-755a-4859-bb7d-d0ffc9e3edb9","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"a12ca521-97c3-43de-a674-652722ca1ee8","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":9,"line":129,"offset":3684}},"value":{"args":[{"id":"6c12e0fc-24ad-4749-a5a2-c81e23dc4748","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":31,"line":129,"offset":3706}}}],"id":"3a37eaed-177b-45fa-b45f-c9970fd3359c","message":"*","metadata":[],"receiver":{"id":"f5145467-ea84-4111-bb1b-0c02958bf535","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":129,"offset":3703},"start":{"column":20,"line":129,"offset":3695}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":20,"line":129,"offset":3695}}},"variable":{"id":"552018da-3983-499c-98f8-093662ac2663","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":129,"offset":3692},"start":{"column":9,"line":129,"offset":3684}}}}],"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":26,"line":128,"offset":3673}}},"id":"ede54acc-4d00-482b-a230-28ce3e853fb9","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":5,"line":128,"offset":3652}}},{"body":{"id":"db27585b-5101-4c3c-a1fa-226a39495a39","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"43a8fb59-bb2b-4cb6-b467-aedb21fb9ac0","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"52d1b975-e435-4681-991c-b813b3f42a87","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"494057db-8f86-408c-ac69-6784440388e7","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"7c627257-22db-4b64-b81b-b80d02470524","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"296e8fd9-5131-4b69-9570-df349204482b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"64d2dbfe-752f-455b-b6c5-68a75a7a594a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"be3c0bf4-b3df-47d2-b178-edc6f39c8f3c","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"69aef4a9-6bff-45ed-982a-85bbb01a730d","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"31e26e23-4a17-4071-a856-5e8baee2d8e0","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"// --------------------------CLASE 2-----------------------------------------"},"name":"comment"},{"args":{"position":"start","text":"/* CONCEPTOS Y OTRAS COSAS\r\nLo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r\nmodelar es lo primero en lo que tenemos que pensar\r\n\r\nOtro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r\nal menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r\nEl polimorfismo es un concepto que permite que diferentes objetos puedan \r\nrecibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r\ninterfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r\n\r\nEn Paradigmas tenemos que saber que TODO puede ser un objeto.\r\n\r\nLos metodos con efecto los reconocemos porque modifican las referencias de \r\nlos objetos, en cambio los de retonrno no lo hacen\r\nCLAVE\r\n-Si retorna -> es de pregunta/retorno\r\n-Si no retorna -> es de efecto/accion\r\n\r\n*,+,&&,|| tambien son mensajes pero de retorno    */"},"name":"comment"},{"args":{"position":"start","text":"/* FECHAS\r\n Metodos para manejar con fechas:\r\n\r\n> const hoy = new Date()\r\n✓\r\n> hoy\r\n✓ 24/11/2017\r\n> hoy.plusYears(1)                 // sumo un año\r\n✓ 24/11/2018                      // devuelve una nueva fecha\r\n> hoy.plusMonths(2)               // sumo 2 meses\r\n✓ 24/1/2018\r\n> hoy.plusDays(20)\r\n✓ 14/12/2017\r\n> hoy.isLeapYear()                // pregunto si el año es bisiesto\r\n✓ false\r\n> hoy.dayOfWeek()                // qué día de la semana es\r\n✓ \"friday\"\r\n> hoy.month()\r\n✓ 11\r\n> hoy.year()\r\n✓ 2017\r\n> const ayer = hoy.minusDays(1)\r\n✓                              // resto un día para obtener el día de ayer\r\n> ayer < hoy                   // comparo fechas\r\n✓ true\r\n> ayer - hoy                   // comparo fechas\r\n✓ -1                          // diferencia en días entre ayer y hoy\r\n> const haceUnMes = hoy.minusMonths(1)\r\n✓\r\n> ayer.between(haceUnMes, hoy)\r\n✓ true                        // ayer está entre hace un mes y hoy\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r\nEn funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r\nbloques que nos van a ayudar a:\r\n-poder generar referencias a dichos bloques\r\n-pasarlos como parámetro\r\n-elegir en qué momento ejecutar una porción de código\r\n\r\n1) Ejemplo de bloque sin parametro\r\n> const abs4 = { => 4.abs() }        \r\n✓\r\n> abs4\r\n✓ { => 4.abs() }\r\n> abs4.apply()                        Con apply() la invocamos para aplicarla\r\n✓ 4\r\n\r\n2) Ejemplo de bloque con parametro (se pueden parametrizar)\r\n>>> const abs = { numero => numero.abs() }\r\n>>\r\n✓\r\n> abs\r\n✓ { numero => numero.abs() }\r\n>>> abs.apply(-8)                     pasamos el parametro mediante el apply\r\n✓ 8\r\n\r\n3) Bloques con dos parámetros \t\r\n> { num1, num2 => num1.max(num2) }.apply(4, 2)\r\n✓ 4\r\n> { num1, num2 => num1 + num2 }.apply(4, 2)\r\n✓ 6\r\n\r\nO bien podemos currificarlo:\r\n> { num1 => { num2 => num1 + num2 }}.apply(4)\r\n✓ { num2 => num1 + num2 }   // devuelve un bloque\r\n\r\n> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r\n✓ 6\r\n\r\n4) Contexto de los bloques\r\nUn dato importante de los closures es que no solo acceden a sus parámetros, \r\nsino también a cualquier otra referencia en el contexto donde fueron definidas. \r\nEsto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r\n\r\n> var to = \"world\"\r\n✓\r\n> const helloWorld = { \"hello \" + to }\r\n✓\r\n> helloWorld.apply()      \t\t\r\n✓ \"hello world\"\r\n> to = \"someone else\"\r\n✓\r\n> helloWorld.apply()      \t\r\n✓ \"hello someone else\"\r\n\r\n> var num = 5\r\n✓\r\n> const bloque = { otroNum => num + otroNum }\r\n✓\r\n> bloque.apply(6)      \t\t\r\n✓ 11\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*\r\n ORDEN SUPERIOR\r\nTambien existen estas funciones que esperan bloques como parametros (retorno) */"},"name":"comment"}],"name":"x","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":131,"offset":3720},"start":{"column":1,"line":125,"offset":3599}},"supertypes":[]},{"id":"34a0abb7-1d76-4d3a-9f46-131e9187589c","members":[{"id":"24e2c8f7-22c8-400e-a3a1-d531b5cd7629","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":5,"line":133,"offset":3738}},"value":{"id":"555a5375-6591-457b-b270-2e759f502619","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":29,"line":133,"offset":3762}},"value":1}},{"body":{"id":"d65bf05d-7f0e-4a6b-864b-fa9461066550","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"2e9543d6-d80a-4c29-9aef-14e7eba55e5e","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":9,"line":136,"offset":3803}},"value":{"args":[{"id":"a7c00001-9526-4200-895f-4b6c1f913f2f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":31,"line":136,"offset":3825}},"value":1}],"id":"4e2ba616-d06f-479a-84ac-fb8c3946060d","message":"+","metadata":[],"receiver":{"id":"4a21b4bf-7234-44ba-8448-37fe08b8b1b4","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":136,"offset":3822},"start":{"column":20,"line":136,"offset":3814}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":20,"line":136,"offset":3814}}},"variable":{"id":"8e83e791-ed3b-4bfa-a471-8d975dbc3ebe","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":136,"offset":3811},"start":{"column":9,"line":136,"offset":3803}}}}],"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":26,"line":135,"offset":3792}}},"id":"b6879720-edd5-426e-b13b-295161df87a8","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":5,"line":135,"offset":3771}}},{"body":{"id":"34db235b-71e7-4f1c-8d5e-67e00cd7a1cc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"94481280-49a4-458b-b73a-a83371475705","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"befef50c-4c0f-4559-a027-2158c50a283d","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"4e3ec355-b3d0-4812-bc5b-1b6eb072ad65","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"5a84e867-4c56-4a0c-9426-3f8ebf42565b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"3b827d65-ddbe-465e-8f21-347a30c10bf4","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"1222c847-6a6b-4b4c-bb07-dadb59457cca","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"e785d452-58ae-4736-98e8-6f046e881cd0","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"0bb2058a-cec1-4e8b-a3d2-a6fb3c75241f","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"814e2a4e-a933-4386-8bba-ec9069483fb6","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"end","text":"/*\r\n>const lista = [x,y]\r\n> lista.filter({objeto => objeto.atributo() >2})\r\n[x]\r\n> lista.map({objeto => objeto.atributo()})\r\n[3,1]\r\n> lista.any ({objeto => objeto.atributo() == 3})\r\ntrue\r\n\r\nY tambien tenemos un metodo que tiene efecto \r\n\r\nlista.forEach({objeto => objeto.incrementar()})\r\n\r\nImportante si queremos usar metodos con efecto vamos a usar forEach solamente,\r\nno map, filter, any, all  */"},"name":"comment"}],"name":"y","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":138,"offset":3832},"start":{"column":1,"line":132,"offset":3722}},"supertypes":[]}],"metadata":[],"name":"clase-2","problems":[{"code":"malformedEntity","sourceMap":{"end":{"column":2,"line":195,"offset":6137},"start":{"column":1,"line":188,"offset":6071}}}],"scope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:22:55.881Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"fileName":"Clases/clase-2.wlk","id":"4f9a25de-acaa-44ed-84f4-a661a694c11e","imports":[],"members":[{"id":"ebbc44e3-4f2a-44f9-8301-14f74d29114c","members":[{"id":"69cc3075-2ce7-46b3-ae21-92af5a22e42a","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":5,"line":126,"offset":3615}},"value":{"id":"5ba21f8c-c917-495e-af6d-9c341f337255","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":126,"offset":3640},"start":{"column":29,"line":126,"offset":3639}},"value":3}},{"body":{"id":"38e8297c-755a-4859-bb7d-d0ffc9e3edb9","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"a12ca521-97c3-43de-a674-652722ca1ee8","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":9,"line":129,"offset":3684}},"value":{"args":[{"id":"6c12e0fc-24ad-4749-a5a2-c81e23dc4748","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":31,"line":129,"offset":3706}}}],"id":"3a37eaed-177b-45fa-b45f-c9970fd3359c","message":"*","metadata":[],"receiver":{"id":"f5145467-ea84-4111-bb1b-0c02958bf535","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":129,"offset":3703},"start":{"column":20,"line":129,"offset":3695}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":39,"line":129,"offset":3714},"start":{"column":20,"line":129,"offset":3695}}},"variable":{"id":"552018da-3983-499c-98f8-093662ac2663","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":129,"offset":3692},"start":{"column":9,"line":129,"offset":3684}}}}],"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":26,"line":128,"offset":3673}}},"id":"ede54acc-4d00-482b-a230-28ce3e853fb9","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":130,"offset":3717},"start":{"column":5,"line":128,"offset":3652}}},{"body":{"id":"db27585b-5101-4c3c-a1fa-226a39495a39","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"43a8fb59-bb2b-4cb6-b467-aedb21fb9ac0","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"52d1b975-e435-4681-991c-b813b3f42a87","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"494057db-8f86-408c-ac69-6784440388e7","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"7c627257-22db-4b64-b81b-b80d02470524","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"296e8fd9-5131-4b69-9570-df349204482b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"64d2dbfe-752f-455b-b6c5-68a75a7a594a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"be3c0bf4-b3df-47d2-b178-edc6f39c8f3c","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"69aef4a9-6bff-45ed-982a-85bbb01a730d","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"31e26e23-4a17-4071-a856-5e8baee2d8e0","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"// --------------------------CLASE 2-----------------------------------------"},"name":"comment"},{"args":{"position":"start","text":"/* CONCEPTOS Y OTRAS COSAS\r\nLo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r\nmodelar es lo primero en lo que tenemos que pensar\r\n\r\nOtro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r\nal menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r\nEl polimorfismo es un concepto que permite que diferentes objetos puedan \r\nrecibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r\ninterfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r\n\r\nEn Paradigmas tenemos que saber que TODO puede ser un objeto.\r\n\r\nLos metodos con efecto los reconocemos porque modifican las referencias de \r\nlos objetos, en cambio los de retonrno no lo hacen\r\nCLAVE\r\n-Si retorna -> es de pregunta/retorno\r\n-Si no retorna -> es de efecto/accion\r\n\r\n*,+,&&,|| tambien son mensajes pero de retorno    */"},"name":"comment"},{"args":{"position":"start","text":"/* FECHAS\r\n Metodos para manejar con fechas:\r\n\r\n> const hoy = new Date()\r\n✓\r\n> hoy\r\n✓ 24/11/2017\r\n> hoy.plusYears(1)                 // sumo un año\r\n✓ 24/11/2018                      // devuelve una nueva fecha\r\n> hoy.plusMonths(2)               // sumo 2 meses\r\n✓ 24/1/2018\r\n> hoy.plusDays(20)\r\n✓ 14/12/2017\r\n> hoy.isLeapYear()                // pregunto si el año es bisiesto\r\n✓ false\r\n> hoy.dayOfWeek()                // qué día de la semana es\r\n✓ \"friday\"\r\n> hoy.month()\r\n✓ 11\r\n> hoy.year()\r\n✓ 2017\r\n> const ayer = hoy.minusDays(1)\r\n✓                              // resto un día para obtener el día de ayer\r\n> ayer < hoy                   // comparo fechas\r\n✓ true\r\n> ayer - hoy                   // comparo fechas\r\n✓ -1                          // diferencia en días entre ayer y hoy\r\n> const haceUnMes = hoy.minusMonths(1)\r\n✓\r\n> ayer.between(haceUnMes, hoy)\r\n✓ true                        // ayer está entre hace un mes y hoy\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r\nEn funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r\nbloques que nos van a ayudar a:\r\n-poder generar referencias a dichos bloques\r\n-pasarlos como parámetro\r\n-elegir en qué momento ejecutar una porción de código\r\n\r\n1) Ejemplo de bloque sin parametro\r\n> const abs4 = { => 4.abs() }        \r\n✓\r\n> abs4\r\n✓ { => 4.abs() }\r\n> abs4.apply()                        Con apply() la invocamos para aplicarla\r\n✓ 4\r\n\r\n2) Ejemplo de bloque con parametro (se pueden parametrizar)\r\n>>> const abs = { numero => numero.abs() }\r\n>>\r\n✓\r\n> abs\r\n✓ { numero => numero.abs() }\r\n>>> abs.apply(-8)                     pasamos el parametro mediante el apply\r\n✓ 8\r\n\r\n3) Bloques con dos parámetros \t\r\n> { num1, num2 => num1.max(num2) }.apply(4, 2)\r\n✓ 4\r\n> { num1, num2 => num1 + num2 }.apply(4, 2)\r\n✓ 6\r\n\r\nO bien podemos currificarlo:\r\n> { num1 => { num2 => num1 + num2 }}.apply(4)\r\n✓ { num2 => num1 + num2 }   // devuelve un bloque\r\n\r\n> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r\n✓ 6\r\n\r\n4) Contexto de los bloques\r\nUn dato importante de los closures es que no solo acceden a sus parámetros, \r\nsino también a cualquier otra referencia en el contexto donde fueron definidas. \r\nEsto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r\n\r\n> var to = \"world\"\r\n✓\r\n> const helloWorld = { \"hello \" + to }\r\n✓\r\n> helloWorld.apply()      \t\t\r\n✓ \"hello world\"\r\n> to = \"someone else\"\r\n✓\r\n> helloWorld.apply()      \t\r\n✓ \"hello someone else\"\r\n\r\n> var num = 5\r\n✓\r\n> const bloque = { otroNum => num + otroNum }\r\n✓\r\n> bloque.apply(6)      \t\t\r\n✓ 11\r\n*/"},"name":"comment"},{"args":{"position":"start","text":"/*\r\n ORDEN SUPERIOR\r\nTambien existen estas funciones que esperan bloques como parametros (retorno) */"},"name":"comment"}],"name":"x","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":131,"offset":3720},"start":{"column":1,"line":125,"offset":3599}},"supertypes":[]},{"id":"34a0abb7-1d76-4d3a-9f46-131e9187589c","members":[{"id":"24e2c8f7-22c8-400e-a3a1-d531b5cd7629","isConstant":false,"isProperty":true,"metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":5,"line":133,"offset":3738}},"value":{"id":"555a5375-6591-457b-b270-2e759f502619","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":30,"line":133,"offset":3763},"start":{"column":29,"line":133,"offset":3762}},"value":1}},{"body":{"id":"d65bf05d-7f0e-4a6b-864b-fa9461066550","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"2e9543d6-d80a-4c29-9aef-14e7eba55e5e","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":9,"line":136,"offset":3803}},"value":{"args":[{"id":"a7c00001-9526-4200-895f-4b6c1f913f2f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":31,"line":136,"offset":3825}},"value":1}],"id":"4e2ba616-d06f-479a-84ac-fb8c3946060d","message":"+","metadata":[],"receiver":{"id":"4a21b4bf-7234-44ba-8448-37fe08b8b1b4","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":28,"line":136,"offset":3822},"start":{"column":20,"line":136,"offset":3814}}},"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":32,"line":136,"offset":3826},"start":{"column":20,"line":136,"offset":3814}}},"variable":{"id":"8e83e791-ed3b-4bfa-a471-8d975dbc3ebe","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":17,"line":136,"offset":3811},"start":{"column":9,"line":136,"offset":3803}}}}],"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":26,"line":135,"offset":3792}}},"id":"b6879720-edd5-426e-b13b-295161df87a8","isOverride":false,"metadata":[],"name":"incrementar","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":2,"line":137,"offset":3829},"start":{"column":5,"line":135,"offset":3771}}},{"body":{"id":"34db235b-71e7-4f1c-8d5e-67e00cd7a1cc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"94481280-49a4-458b-b73a-a83371475705","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"befef50c-4c0f-4559-a027-2158c50a283d","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"4e3ec355-b3d0-4812-bc5b-1b6eb072ad65","isOverride":false,"metadata":[],"name":"atributo","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"5a84e867-4c56-4a0c-9426-3f8ebf42565b","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"3b827d65-ddbe-465e-8f21-347a30c10bf4","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"1222c847-6a6b-4b4c-bb07-dadb59457cca","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"e785d452-58ae-4736-98e8-6f046e881cd0","metadata":[],"name":"atributo","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"0bb2058a-cec1-4e8b-a3d2-a6fb3c75241f","isOverride":false,"metadata":[],"name":"atributo","parameters":[{"id":"814e2a4e-a933-4386-8bba-ec9069483fb6","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"end","text":"/*\r\n>const lista = [x,y]\r\n> lista.filter({objeto => objeto.atributo() >2})\r\n[x]\r\n> lista.map({objeto => objeto.atributo()})\r\n[3,1]\r\n> lista.any ({objeto => objeto.atributo() == 3})\r\ntrue\r\n\r\nY tambien tenemos un metodo que tiene efecto \r\n\r\nlista.forEach({objeto => objeto.incrementar()})\r\n\r\nImportante si queremos usar metodos con efecto vamos a usar forEach solamente,\r\nno map, filter, any, all  */"},"name":"comment"}],"name":"y","problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":138,"offset":3832},"start":{"column":1,"line":132,"offset":3722}},"supertypes":[]}],"metadata":[],"name":"clase-2","problems":[{"code":"malformedEntity","sourceMap":{"end":{"column":2,"line":195,"offset":6137},"start":{"column":1,"line":188,"offset":6071}}}],"scope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:04.340Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":163,"timestamp":"2024-09-16T02:23:06.725Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":107,"timestamp":"2024-09-16T02:23:06.833Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":142,"timestamp":"2024-09-16T02:23:07.702Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":110,"timestamp":"2024-09-16T02:23:08.016Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":143,"timestamp":"2024-09-16T02:23:09.816Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":112,"timestamp":"2024-09-16T02:23:10.195Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":113,"timestamp":"2024-09-16T02:23:10.530Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":105,"timestamp":"2024-09-16T02:23:10.916Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":114,"timestamp":"2024-09-16T02:23:12.380Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:13.475Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:13.538Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:14.777Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":120,"timestamp":"2024-09-16T02:23:15.832Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:15.845Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":118,"timestamp":"2024-09-16T02:23:15.964Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:15.965Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:16.040Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":112,"timestamp":"2024-09-16T02:23:16.153Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":105,"timestamp":"2024-09-16T02:23:16.258Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:21.865Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:22.997Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:26.994Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:30.478Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:34.598Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:35.923Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:37.248Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:38.561Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":104,"timestamp":"2024-09-16T02:23:41.448Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":109,"timestamp":"2024-09-16T02:23:42.473Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:42.473Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:42.542Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":116,"timestamp":"2024-09-16T02:23:42.659Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:42.727Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:43.655Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.e [Field]{7a9a40} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.e [Field]{7a9a40} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.e [Field]{7a9a40} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:44.705Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":102,"timestamp":"2024-09-16T02:23:44.812Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:23:44.812Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":120,"timestamp":"2024-09-16T02:23:45.044Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.en [Field]{3a68c8} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.en [Field]{3a68c8} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.en [Field]{3a68c8} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:45.066Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":115,"timestamp":"2024-09-16T02:23:45.382Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.ener [Field]{4ae0e1} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.ener [Field]{4ae0e1} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.ener [Field]{4ae0e1} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:45.465Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.energ [Field]{6dc026} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.energ [Field]{6dc026} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.energ [Field]{6dc026} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:45.947Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.energi [Field]{7d524b} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.energi [Field]{7d524b} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.energi [Field]{7d524b} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:46.145Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":106,"timestamp":"2024-09-16T02:23:46.252Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.energia [Field]{ebd136} at Clases/clase-2.wlk:189 exhausted all cases without a match Clases.clase-2.toma.energia [Field]{ebd136} at Clases/clase-2.wlk:189 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.energia [Field]{ebd136} at Clases/clase-2.wlk:189 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:23:46.325Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:59.511Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:23:59.732Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"id":"c1737935-b135-45ae-85bc-b8acaeb1105f","members":[{"id":"1774be22-cd16-44b8-92d8-4691aeebd136","isConstant":false,"isProperty":true,"metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":9,"line":191,"offset":6125},"start":{"column":5,"line":189,"offset":6090}},"value":{"id":"d034ea94-b85f-446d-8431-40285b8c2c16","metadata":[],"name":"method","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":9,"line":191,"offset":6125},"start":{"column":3,"line":191,"offset":6119}}}},{"body":{"id":"b2c640f4-1b6d-4457-ab25-b64f1f0cd73d","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[],"sourceMap":{"end":{"column":4,"line":197,"offset":6185},"start":{"column":19,"line":195,"offset":6173}}},"id":"2f364d16-452c-49de-b79f-a821e098b68f","isOverride":false,"metadata":[],"name":"correr","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":4,"line":197,"offset":6185},"start":{"column":3,"line":195,"offset":6157}}},{"body":{"id":"83c74953-ade0-4d30-bc8c-9dee8ae5b33d","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"99ddc4bb-7d5d-4f64-be3a-ca1112c846fc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"f63edcea-cf50-4d19-a8d3-4e2d5269b10a","metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"36029596-c9e7-4458-87f7-9a245f1b7079","isOverride":false,"metadata":[],"name":"energia","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"740aa3b2-c56a-4cfe-81ee-5bb6eb95c5ae","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"bd27a8f2-07fd-4f51-9c42-cbdc0d4ef75f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"3d52aed3-af1f-4fec-b82e-85ab69b9832a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"4a9a19d7-25a4-41d3-aa68-f0626a03fb74","metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"e7cf00a0-df21-4243-a0e6-38429eb2fc45","isOverride":false,"metadata":[],"name":"energia","parameters":[{"id":"7734981c-5e33-49ac-a844-68fea0d5809c","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"/* EJERCICIO TOM Y JERRY\r\n\r\n1)Primera parte\r\nNecesitamos modelar en Wollok a tom que es un gato.\r\nLo que nos interesa de tom es manejar su energía y su velocidad, que dependen de sus actividades de comer ratones y de correr. \r\nLa persona que registra las actividades de tom, registra los ratones que come y la cantidad de tiempo que corre en segundos.\r\n\r\nCuando tom come un ratón aumenta su energía en 12 joules + el peso del ratón en gramos + 10 joules extra si el ratón está feliz.\r\n\r\nLa velocidad de tom es 5 metros x segundo + (energia medida en joules / 10). La velocidad que se toma es la que corresponde a la energía de Tom antes de empezar a correr, y no varía durante una carrera. \r\n\r\nCuando tom corre, su energía disminuye en (0.5 x cantidad de metros que corrió). Observar que la cuenta está en joules consumidos por metro, pero cuando me dicen cuánto corrió, me lo dicen en segundos.\r\n\r\nNota: además de tom, hay otros objetos en juego, ¿cuáles son, qué mensaje tienen que entender?\r\n\r\nJerry es un ratón que tiene un peso que se encuentra relacionado a la cantidad de cosas que comió: El peso del ratón es de 30 gramos de base + el doble de la cantidad de letras que tiene cada alimento \"pesado\" que ingirió. Los alimentos \"pesados\" son los de más de 4 letras. Por ejemplo si comió \"ensalada\", \"pan\" y \"churrasco\" son 30 (de base) + 16 (de ensalada) + 18 (de churrasco) = 64 gr.\r\n\r\nJerry está feliz si alguno de los alimentos que comió es \"pan\". \r\n\r\nMickey es otro ratón que su peso es de 15 gramos y está feliz si el gato que lo quiere comer es su gato favorito Tom.\r\n\r\n2) Segunda parte\r\nLograr que tom entienda el mensaje:\r\ntom.meConvieneComerRatonA(unRaton, unaDistancia)\r\nSe cumple si la energía que gana por comer al ratón es mayor a la que consume corriendo la distancia, que está medida en metros.\r\n\r\n\r\n\r\n*/"},"name":"comment"}],"name":"toma","problems":[{"code":"malformedMember","sourceMap":{"end":{"column":3,"line":195,"offset":6157},"start":{"column":10,"line":191,"offset":6126}}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":199,"offset":6190},"start":{"column":1,"line":188,"offset":6071}},"supertypes":[]},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:03.171Z"}
{"level":"error","message":"✘ Failed to get type description: Error: Failed to print, found malformed node Failed to print, found malformed node","node":{"id":"c1737935-b135-45ae-85bc-b8acaeb1105f","members":[{"id":"1774be22-cd16-44b8-92d8-4691aeebd136","isConstant":false,"isProperty":true,"metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":9,"line":191,"offset":6125},"start":{"column":5,"line":189,"offset":6090}},"value":{"id":"d034ea94-b85f-446d-8431-40285b8c2c16","metadata":[],"name":"method","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":9,"line":191,"offset":6125},"start":{"column":3,"line":191,"offset":6119}}}},{"body":{"id":"b2c640f4-1b6d-4457-ab25-b64f1f0cd73d","metadata":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[],"sourceMap":{"end":{"column":4,"line":197,"offset":6185},"start":{"column":19,"line":195,"offset":6173}}},"id":"2f364d16-452c-49de-b79f-a821e098b68f","isOverride":false,"metadata":[],"name":"correr","parameters":[],"problems":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"sourceMap":{"end":{"column":4,"line":197,"offset":6185},"start":{"column":3,"line":195,"offset":6157}}},{"body":{"id":"83c74953-ade0-4d30-bc8c-9dee8ae5b33d","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"99ddc4bb-7d5d-4f64-be3a-ca1112c846fc","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"f63edcea-cf50-4d19-a8d3-4e2d5269b10a","metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"36029596-c9e7-4458-87f7-9a245f1b7079","isOverride":false,"metadata":[],"name":"energia","parameters":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}},{"body":{"id":"740aa3b2-c56a-4cfe-81ee-5bb6eb95c5ae","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"sentences":[{"id":"bd27a8f2-07fd-4f51-9c42-cbdc0d4ef75f","metadata":[],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"value":{"id":"3d52aed3-af1f-4fec-b82e-85ab69b9832a","metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}},"variable":{"id":"4a9a19d7-25a4-41d3-aa68-f0626a03fb74","metadata":[],"name":"energia","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}}]},"id":"e7cf00a0-df21-4243-a0e6-38429eb2fc45","isOverride":false,"metadata":[],"name":"energia","parameters":[{"id":"7734981c-5e33-49ac-a844-68fea0d5809c","isVarArg":false,"metadata":[],"name":"<value>","scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"contributions":{},"includedScopes":[]}}],"metadata":[{"args":{"position":"start","text":"/* EJERCICIO TOM Y JERRY\r\n\r\n1)Primera parte\r\nNecesitamos modelar en Wollok a tom que es un gato.\r\nLo que nos interesa de tom es manejar su energía y su velocidad, que dependen de sus actividades de comer ratones y de correr. \r\nLa persona que registra las actividades de tom, registra los ratones que come y la cantidad de tiempo que corre en segundos.\r\n\r\nCuando tom come un ratón aumenta su energía en 12 joules + el peso del ratón en gramos + 10 joules extra si el ratón está feliz.\r\n\r\nLa velocidad de tom es 5 metros x segundo + (energia medida en joules / 10). La velocidad que se toma es la que corresponde a la energía de Tom antes de empezar a correr, y no varía durante una carrera. \r\n\r\nCuando tom corre, su energía disminuye en (0.5 x cantidad de metros que corrió). Observar que la cuenta está en joules consumidos por metro, pero cuando me dicen cuánto corrió, me lo dicen en segundos.\r\n\r\nNota: además de tom, hay otros objetos en juego, ¿cuáles son, qué mensaje tienen que entender?\r\n\r\nJerry es un ratón que tiene un peso que se encuentra relacionado a la cantidad de cosas que comió: El peso del ratón es de 30 gramos de base + el doble de la cantidad de letras que tiene cada alimento \"pesado\" que ingirió. Los alimentos \"pesados\" son los de más de 4 letras. Por ejemplo si comió \"ensalada\", \"pan\" y \"churrasco\" son 30 (de base) + 16 (de ensalada) + 18 (de churrasco) = 64 gr.\r\n\r\nJerry está feliz si alguno de los alimentos que comió es \"pan\". \r\n\r\nMickey es otro ratón que su peso es de 15 gramos y está feliz si el gato que lo quiere comer es su gato favorito Tom.\r\n\r\n2) Segunda parte\r\nLograr que tom entienda el mensaje:\r\ntom.meConvieneComerRatonA(unRaton, unaDistancia)\r\nSe cumple si la energía que gana por comer al ratón es mayor a la que consume corriendo la distancia, que está medida en metros.\r\n\r\n\r\n\r\n*/"},"name":"comment"}],"name":"toma","problems":[{"code":"malformedMember","sourceMap":{"end":{"column":3,"line":195,"offset":6157},"start":{"column":10,"line":191,"offset":6126}}}],"scope":{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[{"containerScope":{"containerScope":{"containerScope":{"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]},"contributions":{},"includedScopes":[]}]},"sourceMap":{"end":{"column":2,"line":199,"offset":6190},"start":{"column":1,"line":188,"offset":6071}},"supertypes":[]},"stack":"Error: Failed to print, found malformed node\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:26:15\n    at print (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:19:7)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\hover.js:24:50\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:590:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:03.818Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":125,"timestamp":"2024-09-16T02:24:05.061Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:05.063Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":110,"timestamp":"2024-09-16T02:24:05.272Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":119,"timestamp":"2024-09-16T02:24:05.549Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":133,"timestamp":"2024-09-16T02:24:05.682Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":105,"timestamp":"2024-09-16T02:24:05.881Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Parameter]{247d90} at Clases/clase-2.wlk:195 exhausted all cases without a match [Parameter]{247d90} at Clases/clase-2.wlk:195 exhausted all cases without a match","stack":"Error: [Parameter]{247d90} at Clases/clase-2.wlk:195 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:11.088Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:11.183Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Parameter]{f86d47} at Clases/clase-2.wlk:195 exhausted all cases without a match [Parameter]{f86d47} at Clases/clase-2.wlk:195 exhausted all cases without a match","stack":"Error: [Parameter]{f86d47} at Clases/clase-2.wlk:195 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:11.280Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":288,"timestamp":"2024-09-16T02:24:11.580Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:11.580Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Parameter]{0c92e4} at Clases/clase-2.wlk:195 exhausted all cases without a match [Parameter]{0c92e4} at Clases/clase-2.wlk:195 exhausted all cases without a match","stack":"Error: [Parameter]{0c92e4} at Clases/clase-2.wlk:195 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:11.694Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Parameter]{cb5b3d} at Clases/clase-2.wlk:195 exhausted all cases without a match [Parameter]{cb5b3d} at Clases/clase-2.wlk:195 exhausted all cases without a match","stack":"Error: [Parameter]{cb5b3d} at Clases/clase-2.wlk:195 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:12.111Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:12.296Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":127,"timestamp":"2024-09-16T02:24:19.216Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:19.226Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:19.309Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:19.377Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:24:19.479Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:20.347Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.v [Field]{a798bd} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.v [Field]{a798bd} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.v [Field]{a798bd} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:21.768Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:21.858Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:21.991Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":115,"timestamp":"2024-09-16T02:24:22.107Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.vel [Field]{e89f55} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.vel [Field]{e89f55} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.vel [Field]{e89f55} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:22.206Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":111,"timestamp":"2024-09-16T02:24:22.392Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":113,"timestamp":"2024-09-16T02:24:22.577Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.velod [Field]{ac4e87} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.velod [Field]{ac4e87} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.velod [Field]{ac4e87} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:22.605Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":103,"timestamp":"2024-09-16T02:24:22.708Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.velodci [Field]{8fcdd1} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.velodci [Field]{8fcdd1} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.velodci [Field]{8fcdd1} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:22.864Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:24:22.966Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.velodcida [Field]{1fe91c} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.velodcida [Field]{1fe91c} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.velodcida [Field]{1fe91c} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:23.225Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":104,"timestamp":"2024-09-16T02:24:23.864Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.veloc [Field]{a85c44} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.veloc [Field]{a85c44} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.veloc [Field]{a85c44} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:24.791Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.veloci [Field]{8005df} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.veloci [Field]{8005df} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.veloci [Field]{8005df} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:25.060Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.velocid [Field]{1e6e6f} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.velocid [Field]{1e6e6f} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.velocid [Field]{1e6e6f} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:25.235Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":102,"timestamp":"2024-09-16T02:24:25.338Z"}
{"level":"error","message":"✘ Completions for node failed: Error: Clases.clase-2.toma.velocidad [Field]{efeb7a} at Clases/clase-2.wlk:190 exhausted all cases without a match Clases.clase-2.toma.velocidad [Field]{efeb7a} at Clases/clase-2.wlk:190 exhausted all cases without a match","stack":"Error: Clases.clase-2.toma.velocidad [Field]{efeb7a} at Clases/clase-2.wlk:190 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)\n    at handleMessage (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:339:13)\n    at processMessageQueue (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:362:17)\n    at Immediate._onImmediate (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:334:13)\n    at process.processImmediate (node:internal/timers:478:21)","timestamp":"2024-09-16T02:24:25.474Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":134,"timestamp":"2024-09-16T02:24:26.481Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:24:26.706Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":117,"timestamp":"2024-09-16T02:24:26.900Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":139,"timestamp":"2024-09-16T02:24:27.098Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:30.590Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:31.770Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:32.351Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:32.800Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:34.163Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:34.412Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:35.236Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:36.130Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:44.796Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:44.859Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:44.924Z"}
{"level":"info","message":"⌛ Building environment","timeElapsed":116,"timestamp":"2024-09-16T02:24:45.743Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:24:45.846Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":106,"timestamp":"2024-09-16T02:24:46.246Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":124,"timestamp":"2024-09-16T02:24:46.445Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":112,"timestamp":"2024-09-16T02:24:46.630Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":122,"timestamp":"2024-09-16T02:24:46.831Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:47.374Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:47.444Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:47.603Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":139,"timestamp":"2024-09-16T02:24:47.982Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Assignment]{50b5e6} at Clases/clase-2.wlk:193 exhausted all cases without a match [Assignment]{50b5e6} at Clases/clase-2.wlk:193 exhausted all cases without a match","stack":"Error: [Assignment]{50b5e6} at Clases/clase-2.wlk:193 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at completeForParent (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:56:43)\n    at completeReference (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:64:135)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:84:20\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)","timestamp":"2024-09-16T02:24:50.593Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":121,"timestamp":"2024-09-16T02:24:50.718Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:50.719Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:50.782Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:50.846Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:24:51.092Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":101,"timestamp":"2024-09-16T02:24:51.193Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":270,"timestamp":"2024-09-16T02:24:56.415Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:56.863Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:24:58.465Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:25:01.263Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:25:01.970Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":123,"timestamp":"2024-09-16T02:25:06.364Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":124,"timestamp":"2024-09-16T02:25:06.747Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Send]{b7a5b9} at Clases/clase-2.wlk:193 exhausted all cases without a match [Send]{b7a5b9} at Clases/clase-2.wlk:193 exhausted all cases without a match","stack":"Error: [Send]{b7a5b9} at Clases/clase-2.wlk:193 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at completeForParent (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:56:43)\n    at completeReference (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:64:135)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:84:20\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-languageserver\\lib\\common\\server.js:593:20\n    at handleRequest (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\node_modules\\vscode-jsonrpc\\lib\\common\\connection.js:493:41)","timestamp":"2024-09-16T02:25:07.191Z"}
{"level":"error","message":"✘ Completions for node failed: Error: [Assignment]{36e3fe} at Clases/clase-2.wlk:193 exhausted all cases without a match [Assignment]{36e3fe} at Clases/clase-2.wlk:193 exhausted all cases without a match","stack":"Error: [Assignment]{36e3fe} at Clases/clase-2.wlk:193 exhausted all cases without a match\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:85:11\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at completeForParent (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:56:43)\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:14:46)\n    at completeForParent (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:56:43)\n    at completeReference (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:64:135)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\extensions.js:84:20\n    at completionsForNode (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\node-completion.js:10:44)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\functionalities\\autocomplete\\autocomplete.js:26:154\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\server\\out\\server.js:198:20","timestamp":"2024-09-16T02:25:07.191Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:07.293Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:07.362Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:07.530Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":108,"timestamp":"2024-09-16T02:25:07.639Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:09.362Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:09.527Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:09.692Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":136,"timestamp":"2024-09-16T02:25:09.829Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:09.904Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":149,"timestamp":"2024-09-16T02:25:10.053Z"}
{"level":"info","message":"onRequest - completionItem/resolve","timestamp":"2024-09-16T02:25:10.117Z"}
{"level":"info","message":"⌛ Validating Clases/clase-2.wlk","timeElapsed":110,"timestamp":"2024-09-16T02:25:11.259Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:25:14.515Z"}
{"errors":{"errors":[null,["/* CONCEPTOS Y OTRAS COSAS\r","Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\r","modelar es lo primero en lo que tenemos que pensar\r","Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\r","al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\r","El polimorfismo es un concepto que permite que diferentes objetos puedan \r","recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \r","interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \r","En Paradigmas tenemos que saber que TODO puede ser un objeto.\r","Los metodos con efecto los reconocemos porque modifican las referencias de \r","los objetos, en cambio los de retonrno no lo hacen\r","CLAVE\r","-Si retorna -> es de pregunta/retorno\r","-Si no retorna -> es de efecto/accion\r","/* FECHAS\r","Metodos para manejar con fechas:\r","> const hoy = new Date()\r","✓\r","> hoy\r","✓ 24/11/2017\r","> hoy.plusYears(1)                 // sumo un año\r","✓ 24/11/2018                      // devuelve una nueva fecha\r","> hoy.plusMonths(2)               // sumo 2 meses\r","✓ 24/1/2018\r","> hoy.plusDays(20)\r","✓ 14/12/2017\r","> hoy.isLeapYear()                // pregunto si el año es bisiesto\r","✓ false\r","> hoy.dayOfWeek()                // qué día de la semana es\r","✓ \"friday\"\r","> hoy.month()\r","✓ 11\r","> hoy.year()\r","✓ 2017\r","> const ayer = hoy.minusDays(1)\r","✓                              // resto un día para obtener el día de ayer\r","> ayer < hoy                   // comparo fechas\r","✓ true\r","> ayer - hoy                   // comparo fechas\r","✓ -1                          // diferencia en días entre ayer y hoy\r","> const haceUnMes = hoy.minusMonths(1)\r","✓\r","> ayer.between(haceUnMes, hoy)\r","✓ true                        // ayer está entre hace un mes y hoy\r","/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\r","En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \r","bloques que nos van a ayudar a:\r","-poder generar referencias a dichos bloques\r","-pasarlos como parámetro\r","-elegir en qué momento ejecutar una porción de código\r","1) Ejemplo de bloque sin parametro\r","> const abs4 = { => 4.abs() }        \r","✓\r","> abs4\r","✓ { => 4.abs() }\r","> abs4.apply()                        Con apply() la invocamos para aplicarla\r","✓ 4\r","2) Ejemplo de bloque con parametro (se pueden parametrizar)\r",">>> const abs = { numero => numero.abs() }\r",">>\r","✓\r","> abs\r","✓ { numero => numero.abs() }\r",">>> abs.apply(-8)                     pasamos el parametro mediante el apply\r","✓ 8\r","3) Bloques con dos parámetros \t\r","> { num1, num2 => num1.max(num2) }.apply(4, 2)\r","✓ 4\r","> { num1, num2 => num1 + num2 }.apply(4, 2)\r","✓ 6\r","O bien podemos currificarlo:\r","> { num1 => { num2 => num1 + num2 }}.apply(4)\r","✓ { num2 => num1 + num2 }   // devuelve un bloque\r","> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\r","✓ 6\r","4) Contexto de los bloques\r","Un dato importante de los closures es que no solo acceden a sus parámetros, \r","sino también a cualquier otra referencia en el contexto donde fueron definidas. \r","Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\r","> var to = \"world\"\r","✓\r","> const helloWorld = { \"hello \" + to }\r","✓\r","> helloWorld.apply()      \t\t\r","✓ \"hello world\"\r","> to = \"someone else\"\r","✓\r","> helloWorld.apply()      \t\r","✓ \"hello someone else\"\r","> var num = 5\r","✓\r","> const bloque = { otroNum => num + otroNum }\r","✓\r","> bloque.apply(6)      \t\t\r","✓ 11\r","/*\r","ORDEN SUPERIOR\r"]]},"level":"error","message":"✘ Failed to get type description: Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n} {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}","stack":"Error: {\n  \"errors\": [\n    null,\n    [\n      \"/* CONCEPTOS Y OTRAS COSAS\\r\",\n      \"Lo mas importante en Objetos son los MENSAJES, a la hora de empezar a\\r\",\n      \"modelar es lo primero en lo que tenemos que pensar\\r\",\n      \"Otro concepto igual de importante es el de POLIMORFISMO donde se necesitan\\r\",\n      \"al menos 3 objetos (El objeto que envia el msj y 2 objetos que lo reciben).\\r\",\n      \"El polimorfismo es un concepto que permite que diferentes objetos puedan \\r\",\n      \"recibir un mismo mensaje (mismo metodo) gracias a que comparten la misma \\r\",\n      \"interfaz aunque la implementacion de los metodos sea diferente en c/ uno. \\r\",\n      \"En Paradigmas tenemos que saber que TODO puede ser un objeto.\\r\",\n      \"Los metodos con efecto los reconocemos porque modifican las referencias de \\r\",\n      \"los objetos, en cambio los de retonrno no lo hacen\\r\",\n      \"CLAVE\\r\",\n      \"-Si retorna -> es de pregunta/retorno\\r\",\n      \"-Si no retorna -> es de efecto/accion\\r\",\n      \"/* FECHAS\\r\",\n      \"Metodos para manejar con fechas:\\r\",\n      \"> const hoy = new Date()\\r\",\n      \"✓\\r\",\n      \"> hoy\\r\",\n      \"✓ 24/11/2017\\r\",\n      \"> hoy.plusYears(1)                 // sumo un año\\r\",\n      \"✓ 24/11/2018                      // devuelve una nueva fecha\\r\",\n      \"> hoy.plusMonths(2)               // sumo 2 meses\\r\",\n      \"✓ 24/1/2018\\r\",\n      \"> hoy.plusDays(20)\\r\",\n      \"✓ 14/12/2017\\r\",\n      \"> hoy.isLeapYear()                // pregunto si el año es bisiesto\\r\",\n      \"✓ false\\r\",\n      \"> hoy.dayOfWeek()                // qué día de la semana es\\r\",\n      \"✓ \\\"friday\\\"\\r\",\n      \"> hoy.month()\\r\",\n      \"✓ 11\\r\",\n      \"> hoy.year()\\r\",\n      \"✓ 2017\\r\",\n      \"> const ayer = hoy.minusDays(1)\\r\",\n      \"✓                              // resto un día para obtener el día de ayer\\r\",\n      \"> ayer < hoy                   // comparo fechas\\r\",\n      \"✓ true\\r\",\n      \"> ayer - hoy                   // comparo fechas\\r\",\n      \"✓ -1                          // diferencia en días entre ayer y hoy\\r\",\n      \"> const haceUnMes = hoy.minusMonths(1)\\r\",\n      \"✓\\r\",\n      \"> ayer.between(haceUnMes, hoy)\\r\",\n      \"✓ true                        // ayer está entre hace un mes y hoy\\r\",\n      \"/*  LAMDA/BLOQUES/CLOSURE EN OBJETOS\\r\",\n      \"En funcional las lamda eran funciones anonimas pero aca en Objetos van a ser \\r\",\n      \"bloques que nos van a ayudar a:\\r\",\n      \"-poder generar referencias a dichos bloques\\r\",\n      \"-pasarlos como parámetro\\r\",\n      \"-elegir en qué momento ejecutar una porción de código\\r\",\n      \"1) Ejemplo de bloque sin parametro\\r\",\n      \"> const abs4 = { => 4.abs() }        \\r\",\n      \"✓\\r\",\n      \"> abs4\\r\",\n      \"✓ { => 4.abs() }\\r\",\n      \"> abs4.apply()                        Con apply() la invocamos para aplicarla\\r\",\n      \"✓ 4\\r\",\n      \"2) Ejemplo de bloque con parametro (se pueden parametrizar)\\r\",\n      \">>> const abs = { numero => numero.abs() }\\r\",\n      \">>\\r\",\n      \"✓\\r\",\n      \"> abs\\r\",\n      \"✓ { numero => numero.abs() }\\r\",\n      \">>> abs.apply(-8)                     pasamos el parametro mediante el apply\\r\",\n      \"✓ 8\\r\",\n      \"3) Bloques con dos parámetros \\t\\r\",\n      \"> { num1, num2 => num1.max(num2) }.apply(4, 2)\\r\",\n      \"✓ 4\\r\",\n      \"> { num1, num2 => num1 + num2 }.apply(4, 2)\\r\",\n      \"✓ 6\\r\",\n      \"O bien podemos currificarlo:\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4)\\r\",\n      \"✓ { num2 => num1 + num2 }   // devuelve un bloque\\r\",\n      \"> { num1 => { num2 => num1 + num2 }}.apply(4).apply(2)\\r\",\n      \"✓ 6\\r\",\n      \"4) Contexto de los bloques\\r\",\n      \"Un dato importante de los closures es que no solo acceden a sus parámetros, \\r\",\n      \"sino también a cualquier otra referencia en el contexto donde fueron definidas. \\r\",\n      \"Esto las vuelve realmente poderosas. Veamos un ejemplo muy sencillo:\\r\",\n      \"> var to = \\\"world\\\"\\r\",\n      \"✓\\r\",\n      \"> const helloWorld = { \\\"hello \\\" + to }\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\t\\r\",\n      \"✓ \\\"hello world\\\"\\r\",\n      \"> to = \\\"someone else\\\"\\r\",\n      \"✓\\r\",\n      \"> helloWorld.apply()      \\t\\r\",\n      \"✓ \\\"hello someone else\\\"\\r\",\n      \"> var num = 5\\r\",\n      \"✓\\r\",\n      \"> const bloque = { otroNum => num + otroNum }\\r\",\n      \"✓\\r\",\n      \"> bloque.apply(6)      \\t\\t\\r\",\n      \"✓ 11\\r\",\n      \"/*\\r\",\n      \"ORDEN SUPERIOR\\r\"\n    ]\n  ]\n}\n    at toError (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:102:15)\n    at raise (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:108:9)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:387:35\n    at Monad.apply (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:242:10)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\partial.lenses.validation\\dist\\partial.lenses.validation.cjs.js:386:16)\n    at intersperse (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\infestines\\dist\\infestines.cjs.js:73:14)\n    at splitMetadata (c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:354:134)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:28:22\n    at Array.map (<anonymous>)\n    at c:\\Users\\Jose\\.vscode\\extensions\\uqbar.wollok-lsp-ide-0.3.4\\node_modules\\wollok-ts\\dist\\printer\\print.js:33:286","timestamp":"2024-09-16T02:25:15.086Z"}
